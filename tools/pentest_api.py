from __future__ import annotations

import json
import socket
import sys
import threading
import time
import urllib.error
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Mapping
from unittest.mock import patch

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from usnpw.api.server import APIConfig, create_server


@dataclass(frozen=True)
class _Case:
    name: str
    ok: bool
    detail: str = ""


def _error_code(payload: Mapping[str, object]) -> str:
    error_obj = payload.get("error")
    if isinstance(error_obj, Mapping):
        code = error_obj.get("code")
        if isinstance(code, str):
            return code
    return ""


def _error_message(payload: Mapping[str, object]) -> str:
    error_obj = payload.get("error")
    if isinstance(error_obj, Mapping):
        message = error_obj.get("message")
        if isinstance(message, str):
            return message
    return ""


def _urllib_json_request(
    *,
    port: int,
    method: str,
    path: str,
    token: str | None,
    payload: Mapping[str, object] | None,
    content_type: str = "application/json",
    timeout: float = 3.0,
) -> tuple[int, dict[str, object]]:
    url = f"http://127.0.0.1:{port}{path}"
    headers: dict[str, str] = {}
    body: bytes | None = None
    if payload is not None:
        headers["Content-Type"] = content_type
        body = json.dumps(payload, separators=(",", ":")).encode("utf-8")
    if token is not None:
        headers["Authorization"] = f"Bearer {token}"

    request = urllib.request.Request(url, data=body, headers=headers, method=method)
    try:
        with urllib.request.urlopen(request, timeout=timeout) as response:
            data = response.read().decode("utf-8")
            return response.status, json.loads(data)
    except urllib.error.HTTPError as exc:
        data = exc.read().decode("utf-8")
        return exc.code, json.loads(data)


def _raw_http(
    *,
    port: int,
    request_bytes: bytes,
    timeout: float = 2.0,
) -> bytes:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect(("127.0.0.1", port))
        try:
            sock.sendall(request_bytes)
        except OSError:
            # The server may close early (e.g., overload); still attempt to read any response bytes.
            pass
        out = b""
        while True:
            try:
                chunk = sock.recv(4096)
            except socket.timeout:
                break
            except OSError:
                break
            if not chunk:
                break
            out += chunk
        return out
    finally:
        try:
            sock.close()
        except OSError:
            pass


def _parse_status_line(resp: bytes) -> int:
    head = resp.split(b"\r\n", 1)[0]
    parts = head.split()
    if len(parts) < 2:
        raise ValueError(f"unable to parse status line: {head!r}")
    return int(parts[1].decode("ascii", errors="strict"))


def _probe_overload_status(*, port: int, token: str, attempts: int = 4) -> tuple[int, bytes]:
    body = b"{\"count\":1,\"length\":12,\"format\":\"password\"}"
    raw_req = (
        b"POST /v1/passwords HTTP/1.1\r\n"
        b"Host: 127.0.0.1\r\n"
        b"Authorization: Bearer " + token.encode("ascii") + b"\r\n"
        b"Content-Type: application/json\r\n"
        b"Content-Length: " + str(len(body)).encode("ascii") + b"\r\n"
        b"\r\n"
        + body
    )
    last_status = 0
    last_resp = b""
    for _ in range(max(1, attempts)):
        resp = _raw_http(port=port, request_bytes=raw_req, timeout=2.0)
        if resp:
            last_resp = resp
            try:
                last_status = _parse_status_line(resp)
            except ValueError:
                last_status = 0
            if last_status in (429, 503):
                return last_status, last_resp
        time.sleep(0.05)
    return last_status, last_resp


def _run() -> list[_Case]:
    token = "0123456789abcdef0123456789abcdef"
    config = APIConfig(
        host="127.0.0.1",
        port=0,
        token=token,
        max_body_bytes=1024,
        max_password_count=20,
        max_username_count=20,
        max_concurrent_requests=1,
        max_concurrent_requests_per_client=1,
        socket_timeout_seconds=1.0,
    )
    server = create_server(config)
    port = int(server.server_address[1])
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()

    cases: list[_Case] = []
    try:
        status, payload = _urllib_json_request(port=port, method="GET", path="/healthz", token=None, payload=None)
        cases.append(
            _Case(
                "healthz_open",
                status == 200 and payload.get("status") == "ok",
                f"status={status} payload={payload}",
            )
        )

        status, payload = _urllib_json_request(
            port=port,
            method="POST",
            path="/v1/passwords",
            token=None,
            payload={"count": 1},
        )
        cases.append(
            _Case(
                "auth_required",
                status == 401 and _error_code(payload) == "unauthorized",
                f"status={status} payload={payload}",
            )
        )

        status, payload = _urllib_json_request(
            port=port,
            method="POST",
            path="/v1/passwords",
            token=token,
            payload={"count": 1},
            content_type="application/jsonx",
        )
        cases.append(
            _Case(
                "content_type_strict",
                (
                    status == 400
                    and _error_code(payload) == "invalid_request"
                    and "Content-Type" in _error_message(payload)
                ),
                f"status={status} payload={payload}",
            )
        )

        # Missing Content-Length should 400 and close connection (server cannot safely drain).
        raw_req = (
            b"POST /v1/passwords HTTP/1.1\r\n"
            b"Host: 127.0.0.1\r\n"
            b"Authorization: Bearer " + token.encode("ascii") + b"\r\n"
            b"Content-Type: application/json\r\n"
            b"\r\n"
            b"{\"count\":1}"
        )
        resp = _raw_http(port=port, request_bytes=raw_req)
        status = _parse_status_line(resp)
        cases.append(_Case("missing_content_length", status == 400, f"status={status} resp_head={resp[:120]!r}"))

        # Invalid UTF-8 should 400.
        body = b"\xff\xff"
        raw_req = (
            b"POST /v1/passwords HTTP/1.1\r\n"
            b"Host: 127.0.0.1\r\n"
            b"Authorization: Bearer " + token.encode("ascii") + b"\r\n"
            b"Content-Type: application/json\r\n"
            b"Content-Length: " + str(len(body)).encode("ascii") + b"\r\n"
            b"\r\n"
            + body
        )
        resp = _raw_http(port=port, request_bytes=raw_req)
        status = _parse_status_line(resp)
        cases.append(_Case("invalid_utf8", status == 400, f"status={status} resp_head={resp[:120]!r}"))

        # Oversize payload should 413 and explicitly close connection.
        body = b"X" * 4
        raw_req = (
            b"POST /v1/passwords HTTP/1.1\r\n"
            b"Host: 127.0.0.1\r\n"
            b"Authorization: Bearer " + token.encode("ascii") + b"\r\n"
            b"Content-Type: application/json\r\n"
            b"Content-Length: 2048\r\n"
            b"\r\n"
            + body
        )
        resp = _raw_http(port=port, request_bytes=raw_req)
        status = _parse_status_line(resp)
        cases.append(_Case("oversize_413", status == 413, f"status={status} resp_head={resp[:160]!r}"))

        # Concurrency load shedding: under pressure, the second request should be rejected.
        # Depending on which guard triggers first this may be:
        # - 503: global concurrency cap
        # - 429: per-client concurrency throttle
        entered = threading.Event()
        release = threading.Event()

        from usnpw.api import server as api_server_mod

        real_generate_passwords = api_server_mod.generate_passwords

        def _slow_generate_passwords(req):  # type: ignore[no-untyped-def]
            entered.set()
            if not release.wait(2.0):
                raise RuntimeError("pentest timeout waiting for release")
            return real_generate_passwords(req)

        with patch("usnpw.api.server.generate_passwords", side_effect=_slow_generate_passwords):
            out_status: list[int] = []

            def _call_passwords() -> None:
                status, _ = _urllib_json_request(
                    port=port,
                    method="POST",
                    path="/v1/passwords",
                    token=token,
                    payload={"count": 1, "length": 12, "format": "password"},
                    timeout=3.0,
                )
                out_status.append(status)

            t1 = threading.Thread(target=_call_passwords, daemon=True)
            t1.start()
            if not entered.wait(1.0):
                cases.append(_Case("overload_setup", False, "slow handler not entered"))
            else:
                status2, resp2 = _probe_overload_status(port=port, token=token)
                release.set()
                t1.join(timeout=3.0)
                ok = status2 in (429, 503)
                cases.append(_Case("concurrency_load_shed", ok, f"status={status2} resp_head={resp2[:160]!r}"))

        # Ensure the server still works after the overload test.
        status, payload = _urllib_json_request(
            port=port,
            method="POST",
            path="/v1/passwords",
            token=token,
            payload={"count": 1, "length": 12, "format": "password"},
        )
        cases.append(
            _Case(
                "server_recovers",
                status == 200 and isinstance(payload.get("outputs"), list),
                f"status={status} payload={payload}",
            )
        )

    finally:
        server.shutdown()
        server.server_close()
        thread.join(timeout=2.0)

    return cases


def main(argv: list[str] | None = None) -> int:
    del argv
    cases = _run()
    failed = [c for c in cases if not c.ok]
    for c in cases:
        status = "ok" if c.ok else "FAIL"
        detail = f" {c.detail}" if c.detail else ""
        print(f"[{status}] {c.name}{detail}")
    if failed:
        return 2
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
